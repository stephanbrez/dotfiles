#!/usr/bin/env bash

# *Stowaway-Check* - Interactive wrapper for [stow](https://www.gnu.org/software/stow/) designed for dotfiles management in ðŸ  ($HOME).
#
# This script provides fine-grained control over dotfiles installation, allowing you to selectively install, backup,
# replace, or adopt dotfiles on a package-by-package basis. Perfect for trying dotfiles before committing to them.
#
# KEY FEATURES:
#   â€¢ Interactive conflict resolution with multiple strategies
#   â€¢ Package-level operations (not individual files)
#   â€¢ Backup functionality with automatic collision handling
#   â€¢ Batch processing with "all" options
#   â€¢ Safe operation - never modifies files without user consent
#
# CONFLICT RESOLUTION OPTIONS:
#   Individual Package Options:
#     s - skip: Skip this package entirely
#     r - replace: Replace entire package (no backup)
#     b - backup then install: Backup conflicts, then install package
#     a - add: Install non-conflicting files only (adopt existing)
#     o - backup only: Backup conflicts, don't install
#     i - install: Install package (when no conflicts)
#
#   "All" Batch Options (apply to all remaining packages):
#     S - skip all
#     R - replace all
#     B - backup then install all
#     A - add all
#     O - backup only all
#     I - install all
#
# BACKUP BEHAVIOR:
#   â€¢ Creates timestamped backups when collisions occur (package.backup, package.backup.1643123456)
#   â€¢ "Backup then install" preserves existing files and installs new ones
#   â€¢ "Backup only" preserves existing files without installing anything new
#
# USAGE EXAMPLES:
#   ./stowaway-check ~/.dotfiles ~          # Interactive mode
#   ./stowaway-check -v ~/.dotfiles ~       # Verbose mode
#   ./stowaway-check -y ~/.dotfiles ~       # Auto-yes mode (install all packages)
#
# ARCHITECTURAL NOTES:
#   â€¢ Operates on package level (directories) not individual files
#   â€¢ Uses GNU Stow for symlink management and conflict detection
#   â€¢ Maintains atomic operations - each package is handled independently
#   â€¢ Provides graceful error handling and informative user feedback
#
# WARNINGS:
#   ðŸš¨ "All" options process remaining packages without individual prompts
#   ðŸš¨ Backup operations may fail on read-only filesystems
#   ðŸš¨ Existing backups are never overwritten (timestamped instead)
#
# BATCH MODE:
#   Global "_all" flags persist across packages, allowing "Skip all", "Replace all", etc.
#   This is intentional - once a batch option is selected, it applies to all remaining packages.
#
# ATOMICITY:
#   Operations are NOT atomic. If a stow command fails mid-run:
#   - Previous packages remain stowed
#   - Failed package is reported
#   - Remaining packages are not processed
#   - Backups are preserved (can be manually restored if needed)
#
# INTERRUPTION HANDLING:
#   On Ctrl+C (SIGINT) or SIGTERM:
#   - All backups created during this run are automatically restored
#   - Script exits with code 130
#   - No partial state is left
#
# WHY NOT JUST USE STOW DIRECTLY?
#   â€¢ Stow lacks interactive conflict resolution
#   â€¢ Batch operations don't allow selective package handling
#   â€¢ No built-in backup functionality
#   â€¢ Complex for users trying dotfiles repositories
#
# WHY NOT PASS ALL PACKAGES TO STOW AT ONCE?
#   â€¢ Prevents individual package adoption (--adopt flag)
#   â€¢ Makes it impossible to handle conflicts per-package
#   â€¢ Removes user control over installation process
#
# DEPENDENCIES:
#   â€¢ stow (GNU Stow utility)
#   â€¢ bash (POSIX shell with advanced features)
#
# STANDALONE OPERATION:
#   This script includes built-in function definitions for log-message() and fail()
#   to enable standalone execution without external dependencies.

set -euo pipefail

declare -g BACKUPS_CREATED=()
declare -g ASME=""
declare -g auto_yes=false

cleanup() {
    local restored=0
    for backup_entry in "${BACKUPS_CREATED[@]}"; do
        local backup_path="${backup_entry%%:*}"
        local original_path="${backup_entry##*:}"
        if [ -e "$backup_path" ]; then
            if mv "$backup_path" "$original_path" 2>/dev/null; then
                log-message "INFO" "Restored: $original_path"
                ((restored++))
            fi
        fi
    done
    if [ $restored -gt 0 ]; then
        log-message "WARNING" "Restored $restored backups due to interruption" "true"
    fi
    exit 130
}

trap cleanup INT TERM

setup_user_context() {
    if [ -n "${SUDO_USER:-}" ]; then
        ASME="sudo -u $SUDO_USER"
    else
        ASME=""
    fi
}

log-to-file() {
    if [ -n "${STOWAWAY_LOG:-}" ]; then
        echo "$(date) $*" >> "$STOWAWAY_LOG"
    fi
}

# Function definitions for standalone operation
log-message() {
    local level="$1"
    local message="$2"
    local force="${3:-false}"
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")

    if $verbose_mode || $force; then
        case $level in
        DEBUG) printf "  [ \033[36mDebug\033[0m ][%s] %s\n" "$timestamp" "$message" ;;
        INFO) printf "[ \033[34m>>\033[0m ] %s\n" "$message" ;;
        WARNING) printf "[\033[31m;1 !!! \033[0m][%s] %s\n" "$timestamp" "$message" ;;
        SUCCESS) printf "\033[2K  [ \033[32mOK\033[0m ] %s\n" "$message" ;;
        *) printf "[UNKNOWN][%s] %s\n" "$timestamp" "$message" ;; # Fallback for unknown message types
        esac
    fi
}

fail() {
    printf "\r\033[2K  [ \033[01;31mFAIL\033[0m ] %s\n" "$1"
    echo ''
    exit 1
}

# PARAMETERS:
#   -v, --verbose (optional): Enable verbose output showing debug information
#   src: Source directory containing dotfiles packages (directories)
#   target_dir: Target directory where dotfiles will be installed (typically $HOME)
#
# USAGE EXAMPLES:
#   ./stowaway-check ~/.dotfiles ~                    # Interactive installation
#   ./stowaway-check -v ~/.dotfiles ~                 # Verbose mode
#   ./stowaway-check ~/.dotfiles /tmp/test-home       # Install to test directory
#
# RETURN VALUES:
#   0: Success - all operations completed
#   1: Failure - dependency check failed or critical error
#
# INTERACTIVE PROMPTS:
#   The script presents different prompts based on conflict detection:
#
#   For packages with NO conflicts:
#   "Found [package], what do you want to do: [i]nstall, [I]nstall all, [s]kip, [S]kip all?"
#
#   For packages with conflicts:
#   "Found existing dots at [path], what do you want to do?
#    [s]kip, [S]kip all, [r]eplace, [R]eplace all, [b]ackup then install, [B]ackup then install all,
#    [a]dd, [A]dd all, [o]nly backup, [O]nly backup all?"
#
# USER OPTION REFERENCE:
#   s/S - Skip: Ignore package entirely
#   r/R - Replace: Overwrite without backup
#   b/B - Backup then Install: Preserve existing, add new
#   a/A - Add: Merge non-conflicting files (stow --adopt)
#   o/O - Backup Only: Preserve existing without installing
#   i/I - Install: Standard installation (no conflicts present)
#

# FUNCTION: stowaway_check()
#   Handles conflict resolution and installation for a single dotfiles package
#
# PARAMETERS:
#   src: Path to the package directory (e.g., ~/.dotfiles/zsh)
#   target_dir: Target installation directory (e.g., $HOME)
#
# GLOBALS USED:
#   install_all, replace_all, backup_install_all, backup_only_all, skip_all, add_all
#   verbose_mode
#
# BEHAVIOR:
#   - Checks for stow dependency and target directory existence
#   - Scans for file conflicts between package and target
#   - Presents interactive prompts based on conflict detection
#   - Executes chosen action (install, backup, skip, etc.)
#   - Updates global "all" flags when batch options are selected
#
# RETURNS:
#   Sets global variables and executes stow commands, but returns no value

stowaway_check() {
	local src=$1
	local target_dir="$2"
	local replace="" backup_install="" backup_only="" skip="" install="" add=""
	local stowcmd=""
	local pkgname=""
	local action="" child="" child_name="" found="" cfg_child_name=""

	if ! which stow >/dev/null 2>&1; then
		fail "Skipping dotfiles setup because stow isn't installed."
	elif [ ! -e "$target_dir" ]; then
		fail "Target directory not found"
	fi

	log-message "DEBUG" "Starting stowaway_check for $src"
	log-message "DEBUG" "install_all=$([ "$install_all" == "true" ] && echo true || echo false) \
	replace_all=$([ "$replace_all" == "true" ] && echo true || echo false) \
	backup_install_all=$([ "$backup_install_all" == "true" ] && echo true || echo false) \
	backup_only_all=$([ "$backup_only_all" == "true" ] && echo true || echo false) \
	skip_all=$([ "$skip_all" == "true" ] && echo true || echo false) \
	add_all=$([ "$add_all" == "true" ] && echo true || echo false)"

	pkgname="$(basename "$src")"

	if [ "$install_all" == "false" ] && [ "$replace_all" == "false" ] && [ "$backup_install_all" == "false" ] && [ "$backup_only_all" == "false" ] && [ "$skip_all" == "false" ] && [ "$add_all" == "false" ]; then
		local found=""

		log-message "DEBUG" "searching for children of $src"
		while IFS= read -r -d '' child; do
			cfg_child_name=""
			found=""

			if [ "$skip" == "true" ] || [ "$install" == "true" ]; then
				break
			fi

			log-message "DEBUG" "processing children for $src"
			child_name=$(basename "$child")

			if [ -e "$target_dir/$pkgname/$child_name" ] && [ -f "$child" ]; then
				log-message "DEBUG" "Child Type File"
				found="$target_dir/$pkgname/$child_name"
			fi

			if [ -d "$child" ] && [ "$child_name" = ".config" ]; then
				log-message "DEBUG" "Child Type .config Directory"
				while IFS= read -r -d '' cfg_child; do
					cfg_child_name=$(basename "$cfg_child")
					log-message "DEBUG" "checking for $target_dir/.config/$cfg_child_name"
					if [ -e "$target_dir/.config/$cfg_child_name" ]; then
						found="$target_dir/.config/$cfg_child_name"
						log-message "DEBUG" "found existing dots $found"
						break
					else
						log-message "DEBUG" "couldn't find existing dots"
					fi
				done < <(find "$child" -mindepth 1 -maxdepth 1 -print0)

				if [ -n "$cfg_child_name" ]; then
					log-message "DEBUG" "Exists ${pkgname}/${child_name}/${cfg_child_name} in $found"
				else
					log-message "DEBUG" "Exists ${pkgname}/${child_name} in $found"
				fi
			fi

			if [[ -n $found ]]; then
				local valid_options="sSrRbBaAoO"
				while true; do
					printf "  [ \033[33m??\033[0m ] Found existing dots at %s, what do you want to do? [s]kip, [S]kip all, [r]eplace, [R]eplace all, [b]ackup then install, [B]ackup then install all, [a]dd, [A]dd all, [o]nly backup, [O]nly backup all? " "$found"
					read -r action
					action="${action:0:1}"
					if [[ "$valid_options" == *"$action"* ]]; then
						log-message "DEBUG" "You chose: $action"
						break
					else
						log-message "WARNING" "Invalid option. Please choose either s, S, r, R, b, B, a, A, o or O." "true"
					fi
				done
			else
				if [ -n "$cfg_child_name" ]; then
					log-message "DEBUG" "No existing files at ${target_dir}/${child_name}/${cfg_child_name}"
				else
					log-message "DEBUG" "No existing files at ${target_dir}/$pkgname/${child_name}"
				fi
				local valid_options="iIsS"
				while true; do
					printf "  [ \033[33m??\033[0m ] Found %s, what do you want to do: [i]nstall, [I]nstall all, [s]kip, [S]kip all? " "$pkgname"
					read -r action
					action="${action:0:1}"
					if [[ "$valid_options" == *"$action"* ]]; then
						log-message "DEBUG" "You chose: $action"
						break
					else
						log-message "WARNING" "Invalid option. Please choose either i, I, s, or S." "true"
					fi
				done
			fi

			case "$action" in
			i) install=true ;;
			I) install_all=true ;;
			r) replace=true ;;
			R) replace_all=true ;;
			b) backup_install=true ;;
			B) backup_install_all=true ;;
			o) backup_only=true ;;
			O) backup_only_all=true ;;
			a) add=true ;;
			A) add_all=true ;;
			s) skip=true ;;
			S) skip_all=true ;;
			*) ;;
			esac
			break
		done < <(find "$src" -mindepth 1 -maxdepth 1 -print0)
	fi

	install=${install:-$install_all}
	replace=${replace:-$replace_all}
	backup_install=${backup_install:-$backup_install_all}
	backup_only=${backup_only:-$backup_only_all}
	add=${add:-$add_all}
	skip=${skip:-$skip_all}

	if [ "$replace" == "true" ]; then
		stowcmd="-d $(dirname "$src") -R $pkgname -t $target_dir"
		log-message "INFO" "Replacing $found"
		log-message "WARNING" "When replacing; files in $target_dir but NOT in the repo will still remain." "true"

		log-message "DEBUG" "Executing: stow $stowcmd"
		log-to-file "Stow: stow $stowcmd"
	if ! eval "$ASME stow $stowcmd"; then
			fail "Failed to stow package: $pkgname"
		fi
	fi

	if [ "$backup_install" == "true" ]; then
		local dst=""
		dst="${target_dir}/${pkgname}"
		if [ -e "$dst" ]; then
			local backup_dst="${dst}.backup"
			if [ -e "$backup_dst" ]; then
				backup_dst="${dst}.backup.$(date +%s%N)"
			fi
			if ! mv "$dst" "$backup_dst"; then
				fail "Failed to create backup: $dst -> $backup_dst"
			fi
			log-message "INFO" "Backed up $dst to $backup_dst"
			log-to-file "Backup: $dst -> $backup_dst"
			BACKUPS_CREATED+=("$backup_dst:$dst")
		fi
		stowcmd="-d $(dirname "$src") -S $pkgname -t $target_dir"
		log-message "INFO" "Installing $pkgname after backup"

		log-message "DEBUG" "Executing: stow $stowcmd"
		log-to-file "Stow: stow $stowcmd"
		if ! eval "$ASME stow $stowcmd"; then
			fail "Failed to stow package: $pkgname"
		fi
	fi

	if [ "$backup_only" == "true" ]; then
		local dst=""
		dst="${target_dir}/${pkgname}"
		if [ -e "$dst" ]; then
			local backup_dst="${dst}.backup"
			if [ -e "$backup_dst" ]; then
				backup_dst="${dst}.backup.$(date +%s%N)"
			fi
			if ! mv "$dst" "$backup_dst"; then
				fail "Failed to create backup: $dst -> $backup_dst"
			fi
			log-message "INFO" "Backed up $dst to $backup_dst (not installing)"
			log-to-file "Backup: $dst -> $backup_dst"
			BACKUPS_CREATED+=("$backup_dst:$dst")
		fi
	fi

	if [ "$skip" == "true" ]; then
		log-message "INFO" "Skipping $pkgname"
	fi

	if [ "$skip" != "true" ] && [ "$backup_only" != "true" ]; then
		if [ "$add" == "true" ]; then
			stowcmd="-d $(dirname "$src") -S $pkgname --adopt"
		else
			stowcmd="-d $(dirname "$src") -S $pkgname"
		fi
		log-message "INFO" "Installing $pkgname"

		log-message "DEBUG" "Executing: stow $stowcmd"
		log-to-file "Stow: stow $stowcmd"
		if ! eval "$ASME stow $stowcmd"; then
			fail "Failed to stow package: $pkgname"
		fi
	fi
}

# FUNCTION: stowaway_dots()
#   Main orchestration function that processes all dotfiles packages
#
# PARAMETERS:
#   src: Root directory containing all dotfiles packages
#   target_dir: Target installation directory
#
# GLOBALS SET:
#   Initializes all "*_all" flags to false
#   verbose_mode (from command line arguments)
#
# BEHAVIOR:
#   - Discovers all package directories in source
#   - Processes each package through stowaway_check()
#   - Maintains global state for batch operations
#   - Provides final success confirmation
#
# RETURNS:
#   No return value, exits with success/failure status

	stowaway_dots() {
	local src=$1
	local target_dir="$2"
	local install_all=false replace_all=false backup_install_all=false backup_only_all=false skip_all=false add_all=false
	local dirs=()

	if $auto_yes; then
		install_all=true
		log-message "INFO" "Auto-yes mode enabled: installing all packages"
	fi

	setup_user_context

	if [ ! -e "$target_dir" ]; then
		fail "Target directory not found"
	fi

	if ! $ASME touch "$target_dir/.stowaway-check-write-test" 2>/dev/null; then
		fail "Cannot write to target directory $target_dir as stow user"
	fi
	$ASME rm -f "$target_dir/.stowaway-check-write-test"

	stow_version=$(stow --version 2>/dev/null | head -1 || echo "unknown")
	log-message "DEBUG" "Using $stow_version"

	log-message "DEBUG" "Searching for dots in $target_dir"
	while IFS= read -r dir; do
		dirs+=("$dir")
	done < <(find "$src" -mindepth 1 -maxdepth 1 -type d ! -name '*.git*')

	for dir in "${dirs[@]}"; do
		stowaway_check "$dir" "$target_dir"
	done

	log-message "SUCCESS" "dotfiles installed" "true"
}

# STANDALONE EXECUTION
# When run directly (not sourced), this script processes command line arguments
# and executes the main dotfiles installation workflow
if test "$0" = "${BASH_SOURCE[0]}"; then
	verbose_mode=false
	if [ "$1" = "-v" ] || [ "$1" = "--verbose" ]; then
		verbose_mode=true
		shift
	fi
	if [ "$1" = "-y" ] || [ "$1" = "--yes" ]; then
		auto_yes=true
		shift
	fi

	stowaway_dots "$@"
fi
