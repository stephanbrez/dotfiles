#!/bin/bash

#  ██▓ ███▄    █   ██████ ▄▄▄█████▓ ▄▄▄       ██▓     ██▓    ▓█████  ██▀███
# ▓██▒ ██ ▀█   █ ▒██    ▒ ▓  ██▒ ▓▒▒████▄    ▓██▒    ▓██▒    ▓█   ▀ ▓██ ▒ ██▒
# ▒██▒▓██  ▀█ ██▒░ ▓██▄   ▒ ▓██░ ▒░▒██  ▀█▄  ▒██░    ▒██░    ▒███   ▓██ ░▄█ ▒
# ░██░▓██▒  ▐▌██▒  ▒   ██▒░ ▓██▓ ░ ░██▄▄▄▄██ ▒██░    ▒██░    ▒▓█  ▄ ▒██▀▀█▄
# ░██░▒██░   ▓██░▒██████▒▒  ▒██▒ ░  ▓█   ▓██▒░██████▒░██████▒░▒████▒░██▓ ▒██▒
# ░▓  ░ ▒░   ▒ ▒ ▒ ▒▓▒ ▒ ░  ▒ ░░    ▒▒   ▓▒█░░ ▒░▓  ░░ ▒░▓  ░░░ ▒░ ░░ ▒▓ ░▒▓░
#  ▒ ░░ ░░   ░ ▒░░ ░▒  ░ ░    ░      ▒   ▒▒ ░░ ░ ▒  ░░ ░ ▒  ░ ░ ░  ░  ░▒ ░ ▒░
#  ▒ ░   ░   ░ ░ ░  ░  ░    ░        ░   ▒     ░ ░     ░ ░      ░     ░░   ░
#  ░           ░       ░                 ░  ░    ░  ░    ░  ░   ░  ░   ░

# ╔════════════════════════════════════════════════╗
# ║  ░█▄█░█▀▀░▀█▀░█░█░█▀█░█▀▄░█▀█░█░░░█▀█░█▀▀░█░█  ║
# ║  ░█░█░█▀▀░░█░░█▀█░█░█░█░█░█░█░█░░░█░█░█░█░░█░  ║
# ║  ░▀░▀░▀▀▀░░▀░░▀░▀░▀▀▀░▀▀░░▀▀▀░▀▀▀░▀▀▀░▀▀▀░░▀░  ║
# ╚════════════════════════════════════════════════╝
# Automate the installation of dotfiles and tools
# Distro independent - Also works for Mac
#
# See README.md for documentation on adding new installers
#

#########################################
# Script setup                          #
#########################################
# ─── Detect user and directories ───
# ❗ IMPORTANT: This script should be run with sudo, not as raw root
# Running with sudo preserves the original user context

# Check if running as root
if [ "$EUID" -ne 0 ]; then
	echo "Error: This script must be run with sudo"
	echo "Usage: sudo ./setup"
	exit 1
fi

# Get the real user (the one who ran sudo)
if [ -n "$SUDO_USER" ]; then
	# Normal case: script run with sudo
	me="$SUDO_USER"
	myhome=$(eval echo "~$SUDO_USER")
else
	# Edge case: Running as raw root (Docker, CI, or bad practice)
	# Check if we're in a container or CI environment
	if [ -f /.dockerenv ] || [ -n "$CI" ]; then
		# Allow running as root in containers/CI
		me="root"
		myhome="/root"
	else
		# Not in container - this is bad practice
		echo "Error: Running as raw root is not supported"
		echo "Please run with sudo as a regular user: sudo ./setup"
		exit 1
	fi
fi

basedir="$myhome/.dotfiles"
bindir="$myhome/.local/bin"
repourl="https://github.com/stephanbrez/dotfiles.git"
ARCH=$(uname -m)

# Run commands as the actual user (not root)
ASME="sudo -u $me"

# ─── Architecture mapping for different package formats ───
# uname -m returns: x86_64, aarch64, armv7l, etc.
# dpkg uses: amd64, arm64, armhf, etc.
# GitHub releases vary: x86_64, arm64, aarch64, etc.
case "$ARCH" in
x86_64) ARCH_DEB="amd64" ARCH_GH="x86_64" ;;
aarch64) ARCH_DEB="arm64" ARCH_GH="arm64" ;;
armv7l) ARCH_DEB="armhf" ARCH_GH="armv7" ;;
*) ARCH_DEB="$ARCH" ARCH_GH="$ARCH" ;;
esac
# ======== end user options ======== #

# Initialize modes
verbose_mode=false
dry_run=false
auto_yes=false
install_mode="" # Will be set based on distro or -f flag

# Parse command-line arguments
show_help() {
	cat <<-EOF
		Usage: sudo $0 [OPTIONS]

		❗ This script must be run with sudo to install system packages.

		Options:
		  -v, --verbose    Verbose mode - show detailed output
		  -n, --dry-run    Dry-run mode - preview commands without executing
		  -y, --yes        Auto-yes mode - skip interactive prompts (for CI/testing)
		  -f, --full       Full install mode - force full package installation (overrides minimal)
		  -h, --help       Show this help message

		Installation Modes:
		  - Ubuntu: Minimal mode by default (use -f/--full for full install)
		  - Debian/Other: Full mode always

		Examples:
		  sudo $0 --verbose           Run with verbose output
		  sudo $0 --dry-run           Preview what would be done (no changes made)
		  sudo $0 -v --dry-run        Verbose dry-run
		  sudo $0 --yes               Run non-interactively (auto-accept prompts)
		  sudo $0 --full              Force full installation on Ubuntu
		  sudo $0 --dry-run --yes     Dry-run without prompts (for testing)
	EOF
	exit 0
}

while getopts "vnyfh-:" option; do
	case $option in
	v) verbose_mode=true ;;
	n) dry_run=true ;;
	y) auto_yes=true ;;
	f) install_mode="full" ;;
	h) show_help ;;
	-)
		# Handle long options
		case "${OPTARG}" in
		verbose) verbose_mode=true ;;
		dry-run) dry_run=true ;;
		yes) auto_yes=true ;;
		full) install_mode="full" ;;
		help) show_help ;;
		*)
			echo "Unknown option --${OPTARG}"
			echo "Usage: $0 [-v|--verbose] [-n|--dry-run] [-y|--yes] [-f|--full] [-h|--help]"
			exit 1
			;;
		esac
		;;
	*)
		echo "Usage: $0 [-v|--verbose] [-n|--dry-run] [-y|--yes] [-f|--full] [-h|--help]"
		exit 1
		;;
	esac
done

if $dry_run; then
	echo "═══════════════════════════════════════════════"
	echo "  DRY-RUN MODE - No changes will be made"
	echo "═══════════════════════════════════════════════"
fi
echo "Verbose mode is $verbose_mode"

# ======== helper functions ======== #
function _echo() { printf "\n╓───── %s \n╙────────────────────────────────────── ─ ─ \n" "$1"; }
function user() { printf "\r  [ \033[33m??\033[0m ] %s" "$1"; }
function fail() {
	printf "\r\033[2K  [ \033[01;31mFAIL\033[0m ] %s\n" "$1"
	echo ''
	exit
}

# ─── Dry-run helper functions ───
# Print what would be done in dry-run mode
dry_print() {
	printf "  [ \033[36mDRY\033[0m ] %s\n" "$1"
}

# Check if we should skip execution (dry-run mode)
# Usage: if should_run; then actual_command; fi
# Or:    should_run && actual_command
should_run() {
	! $dry_run
}

log_message() {
	# Function to format and print messages based on the type with optional override to force display (ignore verbose)
	# Usage: log_message "str:MSGTYPE" "str:Message" "boolean:force display"
	local message_type=$1
	local message=$2
	local force=${3:-false}
	local timestamp
	timestamp=$(date +"%Y-%m-%d %H:%M:%S")

	if $verbose_mode || $force; then
		case $message_type in
		DEBUG) printf "  [ \033[36mDebug\033[0m ][%s] %s\n" "$timestamp" "$message" ;;
		INFO) printf "[ \033[34m>>\033[0m ] %s\n" "$message" ;;
		WARNING) printf "[\033[31m;1 !!! \033[0m][%s] %s\n" "$timestamp" "$message" ;;
		SUCCESS) printf "\033[2K  [ \033[32mOK\033[0m ] %s\n" "$message" ;;
		*) printf "[UNKNOWN][%s] %s\n" "$timestamp" "$message" ;; # Fallback for unknown message types
		esac
	fi
}

function linux_package() {
	if [ -x "$(command -v apk)" ]; then
		pkgmgr="apk"
		pkginstall="add --no-cache"
		pkgupdate="update"
	elif [ -x "$(command -v apt)" ]; then
		pkgmgr="apt"
		pkginstall="install -y"
		pkgupdate="update"
		# ─── Detect Debian vs Ubuntu ───
		if [ -f /etc/os-release ]; then
			DISTRO_ID=$(grep "^ID=" /etc/os-release | cut -d'=' -f2 | tr -d '"')
			DISTRO_VERSION=$(grep "^VERSION_ID=" /etc/os-release | cut -d'=' -f2 | tr -d '"')
		else
			DISTRO_ID="debian"
			DISTRO_VERSION="unknown"
		fi
	elif [ -x "$(command -v dnf)" ]; then
		pkgmgr="dnf"
		pkginstall="install -y"
		pkgupdate="update"
	elif [ -x "$(command -v pacman)" ]; then
		pkgmgr="pacman"
		pkginstall="-S"
		pkgupdate="-Syu"
	elif [ -x "$(command -v zypper)" ]; then
		pkgmgr="zypper"
		pkginstall="install"
		pkgupdate="refresh && zypper update"
	else
		fail "Package manager not found. You must manually install packages."
	fi
}
# for avoiding eval some day
# pkgcommands[0] = "$pkgmgr $pkginstall"
# pkgcommands[1] = "$pkgmgr $pkgupdate"

# ─── Source third-party installers ───
for installer in "$basedir"/installers/*.sh; do
	[ -f "$installer" ] && source "$installer"
done

# ======== sanity check ======== #
log_message "INFO" "Detected user: $me (home: $myhome)" "true"
log_message "INFO" "Setting up dotfiles in '$basedir'" "true"
if $auto_yes; then
	log_message "INFO" "Auto-yes mode enabled, continuing..." "true"
else
	while true; do
		user "Do you want to continue? (y/n): "
		read -r -n1 yn
		echo # Move to a new line after reading input
		case $yn in
		y | Y)
			log_message "INFO" "Continuing..." "true"
			break
			;;
		n | N) fail "Exiting." ;;
		*) log_message "WARNING" "Invalid response. Please enter 'y' or 'n'." "true" ;;
		esac
	done
fi

_echo "creating directories"
if should_run; then
	$ASME mkdir -p \
		"$myhome"/.{config,local} \
		"$myhome"/.local/{bin,cache,lib,share,src,state}
	$ASME ln -s "$myhome"/Documents "$myhome"/.local/docs
else
	dry_print "Would create ~/.config, ~/.local and subdirectories"
	dry_print "Would symlink ~/Documents to ~/.local/docs"
fi

#########################################
# Install Packages                      #
#########################################

# ═════ Bootstrap Python Environment ═════
# Install python3 and PyYAML before parsing packages.yaml
# CRITICAL: This must run FIRST on fresh machines
bootstrap_python() {
	_echo "bootstrapping Python environment for package configuration"

	# Determine the correct PyYAML package name for this distro
	local pyyaml_pkg=""
	case "$pkgmgr" in
	apt*)
		pyyaml_pkg="python3-yaml"
		;;
	dnf*)
		pyyaml_pkg="python3-pyyaml"
		;;
	pacman*)
		pyyaml_pkg="python-yaml"
		;;
	*)
		log_message "WARNING" "Unknown package manager, cannot install PyYAML" "true"
		return 1
		;;
	esac

	# Install python3 and PyYAML from system packages (NOT pip!)
	if ! python3 -c "import yaml" 2>/dev/null; then
		log_message "INFO" "Installing python3 and PyYAML from system packages..." "true"
		if should_run; then
			eval "$pkgmgr $pkginstall python3 $pyyaml_pkg"
		else
			dry_print "Would install: python3 $pyyaml_pkg"
		fi
	fi

	# Verify PyYAML is available
	if python3 -c "import yaml" 2>/dev/null; then
		log_message "SUCCESS" "Python environment ready"
		return 0
	else
		log_message "WARNING" "PyYAML not available, falling back to inline definitions" "true"
		return 1
	fi
}

# ═════ YAML Parser ═════
# Parse packages.yaml and export bash arrays for package installation
parse_packages_yaml() {
	local yaml_file="$1"
	local distro="$2"
	local mode="$3"

	if [ ! -f "$yaml_file" ]; then
		log_message "WARNING" "packages.yaml not found, using inline definitions" "true"
		return 1
	fi

	# ─── Check if python3 and PyYAML are available ───
	if ! python3 -c "import yaml" 2>/dev/null; then
		log_message "WARNING" "Python3 or PyYAML not available, using fallback" "true"
		return 1
	fi

	# Use Python to parse YAML and output bash variable assignments
	local python_output
	python_output=$(
		python3 <<EOF
import yaml
import sys

try:
    with open('$yaml_file', 'r') as f:
        config = yaml.safe_load(f)

    # Get common packages
    common_pkgs = config.get('common', {}).get('distro_packages', [])

    # Get distro-specific config
    distro_config = config.get('$distro', {}).get('$mode', {})
    distro_pkgs = distro_config.get('distro_packages', [])

    # Combine and output
    all_pkgs = common_pkgs + distro_pkgs
    print(f"PKG_DISTRO_PACKAGES=({' '.join(all_pkgs)})")

    # Export third-party flags
    third_party = distro_config.get('third_party', {})
    skip_third_party = distro_config.get('skip_third_party', False)

    if skip_third_party:
        print("SKIP_THIRD_PARTY=true")
    else:
        for name, enabled in third_party.items():
            if enabled:
                print(f"INSTALL_{name.upper()}=true")

    # Export pipx packages
    pipx_pkgs = distro_config.get('pipx_packages', [])
    if pipx_pkgs:
        print(f"PKG_PIPX_PACKAGES=({' '.join(pipx_pkgs)})")

except Exception as e:
    print(f"echo 'Error parsing YAML: {e}' >&2", file=sys.stderr)
    sys.exit(1)
EOF
	)
	local python_exit=$?

	if [ $python_exit -ne 0 ] || [ -z "$python_output" ]; then
		log_message "WARNING" "Failed to parse packages.yaml" "true"
		return 1
	fi

	log_message "INFO" "YAML parsed output: $python_output" "true"
	eval "$python_output"
	return 0
}

# ═════ Third-Party Package Installers ═════
# Installer functions are sourced from installers/*.sh

install_pipx_packages() {
	_echo "setting up python + pipx packages"
	if should_run; then
		$ASME pipx ensurepath # add bin path to bash - aka $bindir
		# Install pipx packages from YAML config
		for pkg in "${PKG_PIPX_PACKAGES[@]}"; do
			$ASME pipx install "$pkg"
		done
		# install python neovim after neovim because debian will install old neovim
		eval "$pkgmgr $pkginstall python3-neovim"
	else
		dry_print "Would configure pipx and install: ${PKG_PIPX_PACKAGES[*]} python3-neovim"
	fi
}

function install_packages() {
	_echo "configuring package manager"
	distro=$(lsb_release -c | awk '{print $2}')
	case "$OSTYPE" in
	darwin*)
		pkgmgr="brew"
		pkginstall="install"
		pkgupdate="update"
		;;
	linux*)
		linux_package
		;;
	bsd*)
		# BSD support placeholder
		;;
	msys*)
		echo "WINDOWS"
		;;
	cygwin*)
		echo "ALSO WINDOWS"
		;;
	win32*)
		echo "WINDOWS"
		;;
	*)
		fail "unknown: $OSTYPE"
		;;
	esac

	_echo "updating package manager"
	if should_run; then
		"$pkgmgr" "$pkgupdate"
	else
		dry_print "Would run: $pkgmgr $pkgupdate"
	fi

	# ─── Bootstrap Python + PyYAML (CRITICAL: Must be first!) ───
	bootstrap_python

	# ─── Determine installation mode ───
	if [ -z "$install_mode" ]; then
		# Auto-detect based on distro
		if [[ "$DISTRO_ID" == "ubuntu" ]]; then
			install_mode="minimal"
			log_message "INFO" "Ubuntu detected: using minimal installation mode" "true"
		else
			install_mode="full"
			log_message "INFO" "Using full installation mode" "true"
		fi
	else
		log_message "INFO" "Installation mode forced to: $install_mode" "true"
	fi

	# ─── Load package configuration ───
	packages_yaml="$basedir/packages.yaml"
	USE_YAML_CONFIG=false
	if parse_packages_yaml "$packages_yaml" "$DISTRO_ID" "$install_mode"; then
		log_message "SUCCESS" "Loaded package configuration from YAML"
		USE_YAML_CONFIG=true
	else
		log_message "WARNING" "Using inline package definitions (fallback)" "true"
		USE_YAML_CONFIG=false
	fi

	# install all the things \o/
	_echo "installing packages"

	if [ "$USE_YAML_CONFIG" = true ]; then
		# ─── Install packages from YAML configuration ───
		log_message "INFO" "Installing packages from YAML config..." "true"
		if should_run; then
			eval "$pkgmgr $pkginstall ${PKG_DISTRO_PACKAGES[*]}"
		else
			dry_print "Would install distro packages: ${PKG_DISTRO_PACKAGES[*]}"
		fi
	else
		# ─── Fallback: Install packages from installers/packages-fallback.sh ───
		install_fallback_packages
	fi

	# manually add apt sources
	if should_run; then
		mkdir -p /etc/apt/keyrings
		# add flatpak repo
		flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
	else
		dry_print "Would create /etc/apt/keyrings and add flatpak repo"
	fi

	# ─── Third-party installations ───
	# Skip all third-party if in minimal mode
	if [[ "$SKIP_THIRD_PARTY" == "true" ]]; then
		log_message "INFO" "Skipping third-party installations (minimal mode)" "true"
		return
	fi

	# ─── Install third-party packages based on YAML config flags ───
	log_message "INFO" "Third-party flags: DOCKER=$INSTALL_DOCKER, EZA=$INSTALL_EZA, FASTFETCH=$INSTALL_FASTFETCH" "true"
	log_message "INFO" "Third-party flags: LAZYGIT=$INSTALL_LAZYGIT, NEOVIM=$INSTALL_NEOVIM_SOURCE, UV=$INSTALL_UV" "true"
	[[ "$INSTALL_DOCKER" == "true" ]] && install_docker
	[[ "$INSTALL_ONEPASSWORD" == "true" ]] && install_onepassword
	[[ "$INSTALL_EZA" == "true" ]] && install_eza
	[[ "$INSTALL_FASTFETCH" == "true" ]] && install_fastfetch
	[[ "$INSTALL_FZF_BINARY" == "true" ]] && install_fzf_binary
	[[ "$INSTALL_LAZYDOCKER" == "true" ]] && install_lazydocker
	[[ "$INSTALL_LAZYGIT" == "true" ]] && install_lazygit
	[[ "$INSTALL_NEOVIM_SOURCE" == "true" ]] && install_neovim_source
	[[ "$INSTALL_WEZTERM" == "true" ]] && install_wezterm
	[[ "$INSTALL_ZOXIDE" == "true" ]] && install_zoxide
	[[ "$INSTALL_UV" == "true" ]] && install_uv

	# ─── Install pipx packages if configured ───
	if [ -n "${PKG_PIPX_PACKAGES[*]}" ]; then
		install_pipx_packages
	fi

	# ─── Fun stuff (always install) ───
	# install_figlet_fonts
}

if $auto_yes; then
	log_message "INFO" "Auto-yes mode: installing packages..." "true"
	install_packages
else
	while true; do
		user "Do you want to install packages? (y/n): "
		read -r -n1 yn
		echo # Move to a new line after reading input
		case $yn in
		[Yy]*)
			log_message "INFO" "Continuing with package install..." "true"
			install_packages
			break
			;;
		[Nn]*)
			log_message "INFO" "Skipping package install." "true"
			break
			;;
		*) log_message "WARNING" "Invalid response. Please enter 'y' or 'n'." "true" ;;
		esac
	done
fi

#########################################
# Setup                                 #
#########################################

# ======== setup dotfiles ======== #
# ❗ IMPORTANT: User must clone the repo before running setup
# Usage: git clone https://github.com/stephanbrez/dotfiles.git ~/.dotfiles
#        sudo ~/.dotfiles/setup
_echo "setting up dotfiles"
if should_run; then
	if [ -d "$basedir" ]; then
		log_message "INFO" "Symlinking dotfiles with stow..."
		if $auto_yes; then
			"$basedir/bin/.local/bin/stowaway-check" -y "$basedir" "$myhome"
		else
			"$basedir/bin/.local/bin/stowaway-check" "$basedir" "$myhome"
		fi
	else
		fail "Dotfiles not found at $basedir. Please clone the repo first:\n  git clone $repourl $basedir"
	fi
else
	dry_print "Would run stowaway-check to symlink dotfiles"
fi

# ======== setup fd ======== #
# debian only
if should_run; then
	mkdir -p "$bindir"
	ln -s "$(which fdfind)" "$bindir"/fd
else
	dry_print "Would symlink fdfind to $bindir/fd"
fi

# ======== setup git ======== #
if should_run; then
	if ! $auto_yes; then
		# Git config name
		echo "Please enter your FULL NAME for Git configuration:"
		read -r git_user_name

		# Git config email
		echo "Please enter your EMAIL for Git configuration:"
		read -r git_user_email

		# Set git credentials
		git config --global user.name "$git_user_name"
		git config --global user.email "$git_user_email"
		log_message "SUCCESS" "gitconfig"
	else
		log_message "INFO" "Skipping git config in auto-yes mode"
	fi
else
	dry_print "Would prompt for git user.name and user.email"
fi

# ======== setup tmux ======== #
_echo "setting up tmux"
if should_run; then
	if which tmux >/dev/null 2>&1; then
		tpm="$myhome/.tmux/plugins/tpm"
		$ASME mkdir -p "$tpm"
		if [ -e "$myhome/.config/tmux/plugins/tpm" ]; then
			mv "$myhome/.config/tmux/plugins/tpm" "$tpm"
			pushd "$tpm" >/dev/null &&
				$ASME git pull -q origin master &&
				popd >/dev/null || return
		else
			$ASME git clone --depth=1 https://github.com/tmux-plugins/tpm "$tpm" &&
				$ASME "$tpm"/scripts/install_plugins.sh >/dev/null &&
				$ASME "$tpm"/scripts/clean_plugins.sh >/dev/null &&
				$ASME "$tpm"/scripts/update_plugin.sh >/dev/null
		fi
	else
		fail "Skipping tmux setup because tmux isn't installed."
	fi
else
	dry_print "Would setup tmux plugin manager (tpm)"
fi

# ======== zsh ======== #
_echo "setting up zsh"
if should_run; then
	if which zsh >/dev/null 2>&1; then
		chsh -s "$(which zsh)" "$me"
	fi
else
	dry_print "Would change default shell to zsh"
fi

#########################################
# Manual Install                        #
#########################################
